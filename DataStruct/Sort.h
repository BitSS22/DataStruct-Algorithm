#pragma once

#include <assert.h>
#include "Utility.h"

typedef bool(*Compare)(const int&, const int&);
typedef int Type;

namespace Sort
{
#pragma region Sort Info
	// 매개 변수로 배열, 정렬 규칙 함수를 받는다.
	// 배열의 길이는 템플릿 타입 추론으로 구한다.
	// 함수 템플릿 오버로드로 기본 함수는 DefaultCompare(내림차순)를 사용한다.
	// (람다, 펑터, 함수 포인터 등을 전부 받을 수 있도록 템플릿 오버로드)
	// 함수 포인터가 nullptr이면 assert.

#pragma endregion
#pragma region Bubble
	template <typename Type, size_t Size, typename Compare>
	void BubbleSort(Type(&_Arr)[Size], Compare _Comp) noexcept
	{
		assert(_Comp);
		size_t _Size = Size;

		// 남은 원소 1 이하 == return
		while (_Size > 1)
		{
			for (size_t i = 0; i < _Size - 1; ++i)
			{
				// 다음 원소와 현재 원소 비교, true == Swap
				if (_Comp(_Arr[i + 1], _Arr[i]))
					Utility::Swap(_Arr[i + 1], _Arr[i]);
			}
			// 마지막 원소는 정렬 된 원소이므로 제외
			--_Size;
		}
	}
	template <typename Type, size_t Size>
	void BubbleSort(Type(&_Arr)[Size]) noexcept
	{
		BubbleSort(_Arr, Utility::DefaultCompare<Type>);
	}
#pragma endregion
#pragma region Insert
	template <typename Type, size_t Size, typename Compare>
	void InsertSort(Type(&_Arr)[Size], Compare _Comp) noexcept
	{
		assert(_Comp);

		// 첫번째 원소는 정렬 된 것으로 취급
		for (size_t i = 1; i < Size; ++i)
		{
			size_t CurIndex = i;

			// 현재 인덱스에서 0번 인덱스까지 순차적으로 값 비교
			while (CurIndex > 0)
			{
				// 현재 인덱스와 이전 인덱스의 대소 비교. true라면 둘을 바꾼다.
				// 바뀐 자리의 이전 인덱스와 계속 비교.
				if (_Comp(_Arr[CurIndex], _Arr[CurIndex - 1]))
				{
					Utility::Swap(_Arr[CurIndex], _Arr[CurIndex - 1]);
					--CurIndex;
				}
				else
				{
					// false라면 자기 자리를 찾았으므로 break
					break;
				}
			}
		}
	}
	template <typename Type, size_t Size>
	void InsertSort(Type(&_Arr)[Size]) noexcept
	{
		InsertSort(_Arr, Utility::DefaultCompare<Type>);
	}
#pragma endregion
#pragma region Selection
	template <typename Type, size_t Size, typename Compare>
	void SelectionSort(Type(&_Arr)[Size], Compare _Comp) noexcept
	{
		assert(_Comp);

		// 모든 원소 순회
		for (size_t i = 0; i < Size; ++i)
		{
			// 가장 _Comp에 맞는 원소를 찾는다.
			size_t FindIndex = i;
			for (size_t j = i; j < Size; ++j)
			{
				if (_Comp(_Arr[j], _Arr[FindIndex]))
					FindIndex = j;
			}
			// 찾은 원소를 i번째 원소와 교환한다.
			Utility::Swap(_Arr[i], _Arr[FindIndex]);
		}
	}
	template <typename Type, size_t Size>
	void SelectionSort(Type(&_Arr)[Size]) noexcept
	{
		SelectionSort(_Arr, Utility::DefaultCompare<Type>);
	}
#pragma endregion
#pragma region Merge
	template <typename Type, typename Compare>
	class MergeClass
	{
	public:
		// 생성자를 delete해 객체를 만들 수 없게 하고,
		// Function friend와 private로 다른 함수에서 호출할 수 없게 만든다.
		MergeClass() = delete;
		template <typename T, size_t i, typename Cmp>
		friend void MergeSort(T(&_Arr)[i], Cmp _Comp) noexcept;

	private:
		// 정렬을 수행할 메모리를 저장할 포인터.
		// 기존 Arr, NewArr, Comp를 저장해 함수 인자 갯수를 줄일 것이다.
		// 당연히 데이터 영역에 하나만 있으므로, 쓰레드 언세이프 할 것이다.
		inline static Type* Arr = nullptr;
		inline static Type* NewArr = nullptr;
		inline static Compare Comp = nullptr;

		// 실제 병합, 분할을 하는 함수
		// 배열 크기를 추론하기 힘드니 시작 인덱스와 사이즈를 직접 받겠다.
		static void Merge(size_t _StartIndex, size_t _Size) noexcept
		{
			// 배열 길이를 반으로 자른다. 분할정복 알고리즘.
			// 코드 가독성을 위해 변수를 많이 선언하겠다.
			size_t LeftStart = _StartIndex;
			size_t LeftSize = _Size / 2;
			size_t RightStart = LeftStart + LeftSize;
			size_t RightSize = _Size - LeftSize;

			// 배열 길이가 1이 될 때 까지 계속 나눈다.
			if (LeftSize > 1)
				Merge(LeftStart, LeftSize);

			if (RightSize > 1)
				Merge(RightStart, RightSize);

			// 여기부터는 최초로 올 때 나눈 배열 길이가 각각 1일 것.
			// 이제부터 병합을 시작한다.

			// 각각 배열의 인덱스를 따로 카운트 한다.
			size_t LeftIter = 0;
			size_t RightIter = 0;
			// 실제 기록 될 위치
			size_t WriteIndex = LeftStart;

			// 두 배열의 원소가 둘 다 남아있는가?
			while (LeftIter < LeftSize && RightIter < RightSize)
			{
				// Comp 함수가 true / false에 따라.
				if (Comp(Arr[RightStart + RightIter], Arr[LeftStart + LeftIter]))
				{
					NewArr[WriteIndex] = Arr[RightStart + RightIter];
					++RightIter;
				}
				else
				{
					NewArr[WriteIndex] = Arr[LeftStart + LeftIter];
					++LeftIter;
				}

				// 들어갔으니 다음 복사 될 위치는 다음 인덱스로
				++WriteIndex;
			}

			// 위 반복문이 끝나면 한쪽 배열에만 원소가 남아 있을 것.
			// 나머지 남은 요소들을 채워넣는다.
			// Left
			while (LeftIter < LeftSize)
			{
				NewArr[WriteIndex] = Arr[LeftStart + LeftIter];
				++WriteIndex;
				++LeftIter;
			}
			// Right
			while (RightIter < RightSize)
			{
				NewArr[WriteIndex] = Arr[RightStart + RightIter];
				++WriteIndex;
				++RightIter;
			}

			// 정렬 된 NewArr를 _Arr로 복사한다.
			// 그냥 for문 쓰겠다.
			for (size_t i = _StartIndex; i < _StartIndex + _Size; ++i)
			{
				Arr[i] = MergeClass<Type, Compare>::NewArr[i]);
			}
		}
	};

	template <typename Type, size_t Size, typename Compare>
	void MergeSort(Type (&_Arr)[Size], Compare _Comp) noexcept
	{
		assert(Size);
		assert(_Comp);

		// 같은 사이즈의 배열을 하나 만들었다.
		// 큰 것 하나 만들어서 같이 쓴다.
		MergeClass<Type, Compare>::NewArr = reinterpret_cast<Type*>(malloc(sizeof(Type) * Size));
		// malloc failed, nullptr return.
		if (nullptr == MergeClass<Type, Compare>::NewArr)
			return;

		// MergeClass 변수 값을 설정해준다.
		MergeClass<Type, Compare>::Arr = _Arr;
		MergeClass<Type, Compare>::Comp = _Comp;

		// 실제 정렬은 여기서 수행.
		MergeClass<Type, Compare>::Merge(0, Size);

		// 할당한 메모리 해제.
		// 만약 정렬을 자주 사용한다면 해제는 프로세스 종료시 마지막에 한번만 하는 것도 고려해봄직 하다.
		// (기존의 메모리 크기를 기억해두고, 모자라면 재할당하고, 충분하다면 재사용.)
		free(MergeClass<Type, Compare>::NewArr);

		// 머문 자리도 아름답게.
		MergeClass<Type, Compare>::Arr = nullptr;
		MergeClass<Type, Compare>::NewArr = nullptr;
		MergeClass<Type, Compare>::Comp = nullptr;
	}
	template <typename Type, size_t Size>
	void MergeSort(Type(&_Arr)[Size]) noexcept
	{
		MergeSort(_Arr, Utility::DefaultCompare<Type>);
	}

#pragma endregion
#pragma region Shell
	void ShellSort(Type _Arr[], size_t Size);
#pragma endregion
#pragma region Heap
	void HeapSort(Type _Arr[], size_t Size);
#pragma endregion
#pragma region Quick
	void QuickSort(Type _Arr[], size_t Size);
#pragma endregion
#pragma region Radix
	void RadixSort(Type _Arr[], size_t Size);
#pragma endregion
};
